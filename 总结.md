[toc]
# Map
ConcurrentHashMap
# Operator
## 1. instanceof(A,B),[讲解](https://www.cnblogs.com/ysocean/p/8486500.html),

## [Main_01.java](./src/Operator/Main_01.java)

```java
    boolean result;
    if (obj == null) {
      result = false;
    } else {
      try {
          T temp = (T) obj; // checkcast
          result = true;
      } catch (ClassCastException e) {
          result = false;
      }
    }
```
2. T temp = (T) obj在JVM里的实现？

# JVM
## 1. 运行时数据区域
   1. 程序计数器；当前线程字节码的指示行。
   2. 虚拟机栈：包括方法调用所需：局部变量（基本数据类型、对象引用）、returnaddress等。
   3. 本地方法栈：Native方法调用所需。
   4. 堆：几乎所有对象的实例、数组。
   5. 方法区：类型信息、常量、静态变量、方法代码
      1. 元数据（类的方法代码，变量名，方法名，访问权限，返回值）。
      2. 常量池（字面量和符号引用）
   6. 直接内存
## 2. 对象创建的过程：
   1. 到常量池找

   2. 类加载(静态变量、静态代码块）

   3. 分配内存

   4. 内存初始化为0

   5. 对象设置

   6. 执行构造函数

## 3. 类加载的过程
   1. 加载
      1. 获取字节码（通过类加载器加载字节流）
      2. 转为数据结构
      3. 代表这个类的java.lang.Class对象
   2. 验证
   3. 准备
      1. 为类变量分配空间、设置初始值
   4. 解析：符号引用（类或者接口、）转换为直接引用
   5. 初始化：执行java代码中静态变量、静态代码块
## 4. 类加载器
   1. 三层类加载器
      1. 启动类加载器
      2. 扩展类记载器
      3. 应用类加载器
   2. 双亲委派模型
      1. A收到类加载请求，没加载，先让父加载器看看加载。
      2. 父类加载过了，返回类；没加载过，尝试加载。
      3. 加载失败，再给子加载器加载。
      4. 一个来回，父加载器都没法加载，A的开始自己加载，加载失败则返回失败

